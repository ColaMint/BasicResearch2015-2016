李铭：MySQL集群类型 + 分库分表实际操作 + pt-online-schema-change
================================================================

MySQL集群类型
-------------

Master-Slave(s)
~~~~~~~~~~~~~~~

.. image:: _static/master-slave.png 

在Master-Slave(s)架构中，Master负责写操作，Master和Slave负责读操作。Slave通过Replication与Master同步数据。

特点：

1. 读操作分摊给Slave，减少Master的压力。
#. 在Slave上进行整个数据库的备份对Master来说几乎无影响。
#. Slave即使下线了一段时间，也能通过Replication回到与Master同步的状态，然后继续服务。
#. 若Master宕机，需要下线Master，配置一台Slave为Master，并配置其他Slave与新Master进行Replication。在故障处理期间写操作将全部失败。


Master-Master(-Slaves)
~~~~~~~~~~~~~~~~~~~~~~

.. image:: _static/master-master.png 

在Master-Master(-Slaves)架构中，有两个Master，并且是彼此的Slave。两个Master都能负责写操作和读操作，并且通过Replication同步对方的变化。另外，每个Master还可以额外再配置多几个Slave来分摊写操作的压力。

特点：

1. 两个Master分摊读、写操作的压力。若还配置额外的Slave，Slave也能分摊读操作的压力。
#. 很可能会发生操作冲突，例如两个Master更新了同一条数据。
#. 若其中一个Master宕机，只要先切掉到这台Master的流量即可，此时写操作能被另一台Master承担。


pt-online-schema-change
=======================

`pt-online-schema-change <https://www.percona.com/doc/percona-toolkit/2.2/pt-online-schema-change.htmlhttps://www.percona.com/doc/percona-toolkit/2.2/pt-online-schema-change.html>`_ 是 Percona Toolkit 中的一个工具，它能在不阻塞读、写操作的情况下修改表结构。

我们先创建一张表：

.. code-block:: sql

   CREATE TABLE `test`.`student` ( 
       `id` INT NOT NULL AUTO_INCREMENT ,  
       `name` VARCHAR(10) NOT NULL ,  
       `age` INT NOT NULL ,    
       PRIMARY KEY  (`id`)
   ) ENGINE = InnoDB CHARACTER SET utf8 COLLATE utf8_bin

插入一些数据:

.. code-block:: sql

   INSERT INTO `test`.`student` (`id`, `name`, `age`) VALUES 
   (NULL, '小红', '12'), 
   (NULL, '小黑', '11'), 
   (NULL, '小白', '13'), 
   (NULL, '大黄', '23'), 
   (NULL, '大白', '100')

使用pt-online-schema-change修改表结构：

.. code-block:: sh 

   pt-online-schema-change --alter "ADD COLUMN address VARCHAR(100)" D=test,t=student,u=root,p=root --execute 
   
   No slaves found.  See --recursion-method if host li has slaves.
   Not checking slave lag because no slaves were found and --check-slave-lag was not specified.
   Operation, tries, wait:
      analyze_table, 10, 1
      copy_rows, 10, 0.25
      create_triggers, 10, 1
      drop_triggers, 10, 1
      swap_tables, 10, 1
      update_foreign_keys, 10, 1
   Altering `test`.`student`...
   Creating new table...
   Created new table test._student_new OK.
   Altering new table...
   Altered `test`.`_student_new` OK.

从 binlog 获取相关操作记录：

.. code-block:: sql

   CREATE TABLE `test`.`_student_new` (  
       `id` int(11) NOT NULL AUTO_INCREMENT,  
       `name` varchar(10) COLLATE utf8_bin NOT NULL,  
       `age` int(11) NOT NULL,  
       PRIMARY KEY (`id`)
   ) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 COLLATE=utf8_bin
   ALTER TABLE `test`.`_student_new` ADD COLUMN address VARCHAR(100)
   CREATE DEFINER=`root`@`localhost` TRIGGER `pt_osc_test_student_del` AFTER DELETE ON `test`.`student` FOR EACH ROW DELETE IGNORE FROM `test`.`_student_new` WHERE `test`.`_student_new`.`id` <=> OLD.`id`
   CREATE DEFINER=`root`@`localhost` TRIGGER `pt_osc_test_student_upd` AFTER UPDATE ON `test`.`student` FOR EACH ROW REPLACE INTO `test`.`_student_new` (`id`, `name`, `age`) VALUES (NEW.`id`, NEW.`name`, NEW.`age`)
   CREATE DEFINER=`root`@`localhost` TRIGGER `pt_osc_test_student_ins` AFTER INSERT ON `test`.`student` FOR EACH ROW REPLACE INTO `test`.`_student_new` (`id`, `name`, `age`) VALUES (NEW.`id`, NEW.`name`, NEW.`age`)
   INSERT LOW_PRIORITY IGNORE INTO `test`.`_student_new` (`id`, `name`, `age`) SELECT `id`, `name`, `age` FROM `test`.`student` LOCK IN SHARE MODE /*pt-online-schema-change 6965 copy table*/
   ANALYZE TABLE `test`.`_student_new` /* pt-online-schema-change */
   RENAME TABLE `test`.`student` TO `test`.`_student_old`, `test`.`_student_new` TO `test`.`student`
   DROP TRIGGER IF EXISTS `test`.`pt_osc_test_student_del`
   DROP TRIGGER IF EXISTS `test`.`pt_osc_test_student_upd`
   DROP TRIGGER IF EXISTS `test`.`pt_osc_test_student_ins`
   DROP TABLE IF EXISTS `_student_old` /* generated by server */

由此我们可以分析出pt-online-schema-change的工作原理：

    1. 创建一张与被修改的表结构一样的表
    #. 修改新表的表结构
    #. 在旧表创建删除、更新、插入三个触发器来让接下来复制过程中发生的操作也反应到新表
    #. 通过`LOCK IN SHARE MODE`在旧表所读取的行加读锁，将旧表的数据复制到新表
    #. 重命名旧表和新表
    #. 删除第3步创建的触发器
    #. 删除旧表

请注意：

    1. 在第4步中对所读的行加了读锁，这对数据库的正常写入还是有一定的影响的。可以通过--chunk-time配置每阶段复制的时长，或通过--chunk-size配置每阶段最多复制的行数^
    #. 若被修改结构的表是其他表的外键所引用的表，需要使用--alter-foreign-keys-method来自动修改其他表的外键引用新表
    #. 目前只有使用InnoD引擎的表才能使用该工具修改表结构



参考资料
--------

    -- 《高性能MySQL》

    -- http://weibo.com/p/1001643874615465508614

    -- http://skillachie.com/2014/07/25/mysql-high-availability-architectures/#MySQL_Cluster

    -- http://erlycoder.com/43/mysql-master-slave-and-master-master-replication-step-by-step-configuration-instructions-

    -- https://www.percona.com/doc/percona-toolkit/2.2/pt-online-schema-change.html 
